---
title: "DM2_questions_2-3"
author: "AIGOIN Emilie"
date: "2025-11-22"
output: html_document
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE)

```

# Partie 2 — Programmation

```{r setup_inputs, eval=FALSE, echo=TRUE}

# Définition des entrées (exemple à ne pas exécuter)

X <- as.matrix(X)                 # matrice n x p
Y <- as.matrix(Y)                 # matrice n x q
H <- 3                            # nombre de composantes
w <- rep(1 / nrow(X), nrow(X))    # poids égaux
M <- diag(ncol(X))                # matrice métrique identité
center_scale <- TRUE              # centrage-réduction activée

```

Afin d’assurer une formulation claire et homogène des opérations, nous définissons quelques fonctions utiles. Elles permettent notamment de gérer les produits scalaires pondérés, les normes induites par un vecteur de poids, ainsi que les transformations associées à la métrique $M$.

```{r setup_inputs_1, echo=TRUE}

# Matrice de pondération diagonale à partir d’un vecteur w

Wmat <- function(w) {
  if (is.null(w)) return(NULL)
  diag(as.numeric(w), nrow = length(w))
}

# Norme pondérée avec w vecteur poids ou W matrice diag

w_norm2 <- function(v, w) {
  if (is.null(w)) return(as.numeric(t(v) %*% v))
  as.numeric(t(v) %*% (w * v))
}

# Produit scalaire pondéré

w_prod <- function(a, b, w) {
  if (is.null(w)) return(as.numeric(t(a) %*% b))
  as.numeric(t(a) %*% (w * b))
}

# Racine symétrique de M (M supposée SPD ou semi-définie)

M_half <- function(M) {
  ev <- eigen(M, symmetric = TRUE)
  vals <- pmax(ev$values, 0)
  vecs <- ev$vectors
  vecs %*% diag(sqrt(vals), length(vals)) %*% t(vecs)
}

# Inverse de la racine symétrique de M (pseudo-inverse si valeurs nulles)

M_half_inv <- function(M) {
  ev <- eigen(M, symmetric = TRUE)
  vals <- ev$values
  vecs <- ev$vectors
  invvals <- ifelse(vals > 0, 1 / sqrt(vals), 0)
  vecs %*% diag(invvals, length(invvals)) %*% t(vecs)
}

```

## 1. Calcul des H premières composantes ADPLS

L’algorithme ci-dessous renvoie les vecteurs $u_h$, les composantes discriminantes $F = (f_h)$, les composantes normalsiées $\tilde F$, ainsi que les quantités intermédiaires $\widehat X$, $E$ et le projecteur $\Pi_Y$.

```{r adpls_part1, echo=TRUE}

adpls_part1 <- function(X, Y, H = 2, w = NULL, M = NULL, center_scale = TRUE) {
  
# Conversion explicite en matrices et extraction des dimensions
  X <- as.matrix(X)
  Y <- as.matrix(Y)
  n <- nrow(X)
  p <- ncol(X)
  
# Vérification : X et Y doivent décrire les mêmes individus
  if (nrow(Y) != n) stop(" X et Y doivent avoir le même nombre de lignes (individus)")

# Construction du vecteur de poids w 
  if (is.null(w)) w <- rep(1 / n, n)
  w <- as.numeric(w)
  if (length(w) != n) stop("Longueur de w différente de n (nrow(X))")
  W <- diag(w)
  
# Centrage-réduction éventuel de X
  if (center_scale) X <- scale(X, center = TRUE, scale = TRUE)
  
# Matrice métrique M (M = I par défaut)
  if (is.null(M)) M <- diag(1, p)
  if (!all(dim(M) == c(p, p))) stop("M doit être p x p")
  
# Calcul de racines de M
  sqrtM <- M_half(M)
  inv_sqrtM <- M_half_inv(M)
  
# Projecteur Pi_Y
  YYw <- t(Y) %*% (W %*% Y)
  inv_YYw <- solve(YYw)
  PiY <- Y %*% inv_YYw %*% t(Y) %*% W
  
# Projection de X sur l'espace de Y
  Xhat <- PiY %*% X
  
# Matrice E (pour la diagonalisation)
  E <- t(Xhat) %*% (W %*% Xhat)
  
# Réservation des objets de sortie
  if (is.null(H) || !is.numeric(H) || H < 1) stop("H doit être un entier positif")
  H <- as.integer(H)
  U_list <- vector("list", H) 
  F <- matrix(0, n, H)
  Ftilde <- matrix(0, n, H)
  
# Boucle sur h = 1...H
  for (h in seq_len(H)) {
    if (h == 1) {
      
# Première composante : diagonalisation de E* = M^{1/2} E M^{1/2}
      Estar <- sqrtM %*% E %*% sqrtM
      ev <- eigen(Estar, symmetric = TRUE)
      
# Vecteur propre principal en métrique transformée
      ustar <- ev$vectors[, 1]
      
# Retour dans l'espace u : u = M^{-1/2} u*
      u <- inv_sqrtM %*% ustar
      
# Normalisation selon la contrainte u'Mu = 1
      unorm <- as.numeric(t(u) %*% (M %*% u))
      if (unorm <= 0) stop("Norme u'Mu non strictement positive")
      u <- u / sqrt(unorm)
      
    } else {
      
# Construction de D' = F_{h-1}' W X
      Fprev <- F[, 1:(h - 1), drop = FALSE]
      Dprime <- t(Fprev) %*% (W %*% X)
      D <- t(Dprime)
      
# Construction de Pi_{D^\perp} = I - D(D'MD)^{-1}D'M
      inner <- t(D) %*% (M %*% D)
      inv_inner <- solve(inner)
      PiDperp <- diag(1, p) - D %*% inv_inner %*% t(D) %*% M
      
# Matrice à diagonaliser : M^{1/2} Pi_{D^\perp} E M Pi_{D^\perp}' M^{1/2}
      Estar_proj <- sqrtM %*% PiDperp %*% E %*% t(PiDperp) %*% sqrtM
      ev <- eigen(Estar_proj, symmetric = TRUE)
      
# Premier vecteur propre dans l’espace réduit
      ustar <- ev$vectors[, 1]
      u <- inv_sqrtM %*% ustar
      
# Normalisation selon la contrainte u'Mu = 1
      unorm <- as.numeric(t(u) %*% (M %*% u))
      if (unorm <= 0) stop(paste("Norme u'Mu non positive (h=", h, ")", sep = ""))
      u <- u / sqrt(unorm)
    }
    
# Calcul du score f_h = X M u
    f_h <- X %*% (M %*% u)
    
# Normalisation pondérée : f_tilde_h = f_h / ||f_h||_W
    fnorm2 <- as.numeric(t(f_h) %*% (W %*% f_h))
    if (fnorm2 <= 0) stop(paste("Norme de f_h <= 0 (h=", h, ")", sep = ""))
    ftilde_h <- f_h / sqrt(fnorm2)
    
# Stockage des résultats
    U_list[[h]] <- as.numeric(u)
    F[, h] <- as.numeric(f_h)
    Ftilde[, h] <- as.numeric(ftilde_h)
  }
  
# Conversion de la liste de vecteurs en matrice p x H
  U_mat <- do.call(cbind, U_list)
  colnames(U_mat) <- paste0("u", seq_len(ncol(U_mat)))
  colnames(F) <- paste0("f", seq_len(ncol(F)))
  colnames(Ftilde) <- paste0("f_tilde", seq_len(ncol(Ftilde)))
  
  return(list(U = U_mat, F = F, Ftilde = Ftilde, Xhat = Xhat, 
              E = E, PiY = PiY, M = M, w = w))
}
```

## 2. Calcul des indicateurs $S(f_h)$ et $R^2 (f_h, Y)$

L’implémentation suivante exploite les résultats de la fonction `adpls_part1` et procède, pour chaque composante, au calcul des normes pondérées nécessaires à l’obtention des deux indicateurs.

```{r adpls_part2, echo=TRUE}

adpls_part2 <- function(X, Y, H = 2, w = NULL, M = NULL, center_scale = TRUE) {
  
# Réutilise la fonction adpls_part1
  part1 <- adpls_part1(X, Y, H, w, M, center_scale)
  
# Préparation des objets utiles
  X <- as.matrix(X)
  if (center_scale) X <- scale(X,             # centrer-réduire X si nécessaire
                               center = TRUE, 
                               scale = TRUE)   
  n <- nrow(X)
  W <- diag(part1$w)
  M <- part1$M
  F <- part1$F
  U <- part1$U
  Xhat <- part1$Xhat
  E <- part1$E
  
# Calcul de l'inertie totale sur X transformé
  total_inertia <- sum(diag(t(X) %*% (W %*% X)))
  
# Réservation des vecteurs résultats
  S_vec <- numeric(H)
  R2_vec <- numeric(H)
  
# Boucle sur h
  for (h in seq_len(H)) {
    
# Extraction de f_h
    f_h <- F[, h, drop = FALSE]
    
# Norme pondérée
    fnorm2 <- as.numeric(t(f_h) %*% (W %*% f_h))
    
# Calcul de S(f_h)
    S_vec[h] <- fnorm2 / total_inertia
    
# Projection PiY*f_h
    fhat_h <- part1$PiY %*% f_h
    
# Norme pondérée de la projection
    top_val <- as.numeric(t(fhat_h) %*% (W %*% fhat_h))
    
# Calcul du coefficient de détermination R²
    R2_vec[h] <- top_val / fnorm2
  }
  
# Ajout des indicateurs au résultat final
  part1$S <- S_vec
  part1$R2 <- R2_vec
  
  return(part1)
}

```

## 3. Calcul des coordonnées des centres de gravité des $q$ classes sur les $H$ axes discriminants

L’implémentation est donnée ci-dessous.

```{r adpls_part3, echo=TRUE}

adpls_part3 <- function(X, Y, H = 2, w = NULL, M = NULL, center_scale = TRUE) {

# Réutilise la fonction adpls_part2
  part2 <- adpls_part2(X, Y, H, w, M, center_scale)
  
# Préparation des objets utiles
  W <- diag(part2$w)
  F <- part2$F
  Y <- as.matrix(Y)
  
# Calcul des centres de gravité : G = (Y'WY)^{-1} Y'WF
  YtWY <- t(Y) %*% W %*% Y
  YtWF <- t(Y) %*% W %*% F
  G <- solve(YtWY, YtWF)
  
  rownames(G) <- colnames(Y)
  colnames(G) <- paste0("Axe_", seq_len(H))
  
# Ajout des résultats
  part2$centers <- G
  
  return(part2)
}

```

## 4. Calcul des coordonnées des variables de X

```{r adpls_part4, echo=TRUE}

adpls_part4 <- function(X, Y, H = 2, w = NULL, M = NULL, center_scale = TRUE) {

# Réutilise la fonction adpls_part3
  part3 <- adpls_part3(X, Y, H, w, M, center_scale)
  
# Préparation des objets utiles
  W <- diag(part3$w)
  F <- part3$F
  
# X transformé de la même manière que dans la partie 1
  X <- as.matrix(X)
  if (center_scale) X <- scale(X, center = TRUE, scale = TRUE)
  n <- nrow(X)
  p <- ncol(X)
  
# Matrice des corrélations
  C <- matrix(0, nrow = p, ncol = H)
  
# Calcul de corrélations pondérées entre X_j et f_h
  for (j in 1:p) {
    xj <- X[, j]
    norm_xj <- sqrt(as.numeric(t(xj) %*% (W %*% xj)))
    
    for (h in 1:H) {
      fh <- F[, h]
      norm_fh <- sqrt(as.numeric(t(fh) %*% (W %*% fh)))
      if (norm_xj == 0 || norm_fh == 0) {
        C[j, h] <- 0
      } else {
        C[j, h] <- as.numeric(t(xj) %*% (W %*% fh)) / (norm_xj * norm_fh)
      }
    }
  }
  
  rownames(C) <- colnames(X)
  colnames(C) <- paste0("Axe_", seq_len(H))
  
# Ajout des résultats
  part3$var_coords <- C
  
  return(part3)
}

```

### Fonction générale — intégration du processus ADPLS

Afin de simplifier l'utilisation de l'ADPLS, nous avons implémenté une fonction générale `adpls_full()` qui regroupe l'ensemble des étapes de calcul présentées précédemment (questions 1 à 4).

Cette fonction permet d'obtenir directement, à partir des matrices d'entrées $X$ et $Y$, tous les résultats nécessaires à l'analyse discriminante : composantes discriminantes, indicateurs de qualité, coordonnées des centres de gravité et coordonnées des variables. Elle évite ainsi d'avoir à appeler successivement les quatre fonctions intermédiaires et simplifie considérablement le processus d'analyse pour l'utilisateur final.

```{r adpls_full}

adpls_full <- function(X, Y, H=2, w=NULL, M=NULL, center_scale=TRUE){
  
# Fonctions utilitaires internes
  Wmat <- function(w) {
    if (is.null(w)) return(NULL)
    diag(as.numeric(w), nrow = length(w))
  }

  w_norm2 <- function(v, w) {
    if (is.null(w)) return(sum(v^2))
    as.numeric(t(v) %*% (w * v))
  }

  w_prod <- function(a, b, w) {
    if (is.null(w)) return(as.numeric(t(a) %*% b))
    as.numeric(t(a) %*% (w * b))
  }

  M_half <- function(M) {
    ev <- eigen(M, symmetric = TRUE)
    vals <- pmax(ev$values, 0)
    vecs <- ev$vectors
    vecs %*% diag(sqrt(vals), length(vals)) %*% t(vecs)
  }
  
  M_half_inv <- function(M) {
    ev <- eigen(M, symmetric = TRUE)
    vals <- ev$values
    vecs <- ev$vectors
    invvals <- ifelse(vals > 0, 1 / sqrt(vals), 0)
    vecs %*% diag(invvals, length(invvals)) %*% t(vecs)
  }
 
 if (is.null(w)) w <- rep(1 / nrow(X), nrow(X))
  
# Enchainement des étapes de calcul
  part1 <- adpls_part1(X = X, Y = Y, H = H, w = w, M = M, center_scale = center_scale)
  part2 <- adpls_part2(X = X, Y = Y, H = H, w = w, M = M, center_scale = center_scale)
  part3 <- adpls_part3(X = X, Y = Y, H = H, w = w, M = M, center_scale = center_scale)
  part4 <- adpls_part4(X = X, Y = Y, H = H, w = w, M = M, center_scale = center_scale)

# Extraction et renvoi des résultats essentiels 
  return(list(F = part1$F, 
              Ftilde = part1$Ftilde,
              S = part2$S, 
              R2 = part2$R2,
              centers = part3$centers,
              var_coords = part4$var_coords))
}
```

Cette fonction constitue l'outil principal pour effectuer une analyse ADPLS complète en une seule instruction. Elle retourne une liste contenant:

- `F` correspond à $F$ : les composantes discriminantes brutes.
- `Ftilde` correspond à $\tilde F$ : les composantes discriminantes normalisées.
- `S` correspond à $S$ : les proportions d'inertie expliquées.
- `R2` correspond à $R^2$ : les coefficients de détermination.
- `centers` : les coordonnées des centres de gravité des classes.
- `var_coords` : les coordonnées des variables sur les axes discriminants.

## 5. Représentation graphique des individus, des centres de gravité et des variables

```{r plot_adpls, echo=TRUE }

library(RColorBrewer)

plot_adpls <- function(out, Y = NULL, Y_labels = NULL, h = 1, m = 2,
                       show_variables = TRUE, circle = TRUE,
                       main = NULL, cex_ind = 0.7, cex_cent = 1.0,
                       xlim = NULL, ylim = NULL) {

  Ftilde <- out$Ftilde
  centers <- out$centers
  var_coords <- out$var_coords
  n <- nrow(Ftilde)
  
# Identification des étiquettes de classes
  if (is.null(Y_labels) & !is.null(Y)) {
    lab <- apply(Y, 1, function(r) which(r == 1))
    Y_labels <- factor(lab)
  } else if (is.null(Y_labels)) {
    stop("Y_labels ou Y doivent être fournis!")
  }
  
# Coordonnées des individus sur les axes (h, m)
  xind <- Ftilde[, h]
  yind <- Ftilde[, m]
  classes <- as.factor(Y_labels)
  
# Palette de couleurs
  n_classes <- length(levels(classes))
  cols <- brewer.pal(min(max(n_classes, 3), 8), "Set2")
  if (n_classes > 8) cols <- rep(cols, length.out = n_classes)
  
# Tracé des individus
  plot(xind, yind,
       col = adjustcolor(cols[as.numeric(classes)], alpha.f = 0.7),
       pch = 19,
       cex = cex_ind,
       xlab = paste0("Axe ", h),
       ylab = paste0("Axe ", m),
       main = main,
       bg = "white",
       xlim = xlim,
       ylim = ylim)
  
# Légende
  legend("topright",
         legend = levels(classes),
         col = cols,
         pch = 19,
         cex = 1,
         title = "Classes",
         bg = "white",
         box.lwd = 0.5, 
         box.col = "black",
         text.col = "black")
  
# Centres de gravité
  points(centers[, h], centers[, m], col = "black", pch = 8, cex = cex_cent)
  text(centers[, h], centers[, m], labels = rownames(centers), pos = 3)
  
# Représentation des variables dans le plan
  if (show_variables) {
    arrows(rep(0, nrow(var_coords)), rep(0, nrow(var_coords)),
           var_coords[, h], var_coords[, m],
           length = 0.07, col = "grey40", lwd = 1)
    
    # Décalage des étiquettes
    scale_factor <- 1.15  # Décalage de 15%
    text(var_coords[, h] * scale_factor, 
         var_coords[, m] * scale_factor,
         labels = rownames(var_coords),
         cex = 0.7, col = "grey20")
    
# Cercle unité pour l'interprétation des corrélations
    if (circle) {
      angles <- seq(0, 2*pi, length.out = 200)
      lines(cos(angles), sin(angles), lty = 2, col = "black")
    }
  }
}

# Opérateur utilitaire : renvoie a si non nul, sinon b
`%||%` <- function(a, b) if (!is.null(a)) a else b

```

# Partie 3 — Application: types forestiers du bassin du Congo

## 1. Chargement des données et ADPLS exploratoire

Tout d’abord, nous chargeons le fichier contenant les informations sur 27 espèces d'arbres $X = [gen1, …, gen27]$. La variable $Y = \text{forest}$ identifie le type forestier de chaque observation.

```{r dataset}

# Jeu de données
data <- read.table("Datagenus.csv", header = TRUE)

# Variables explicatives : 27 espèces d'arbres
X <- scale(as.matrix(data[, paste0("gen", 1:27)]), center = TRUE, scale = TRUE)

# Variable à expliquer : type de forêt
grp <- as.factor(data$forest)
Y <- model.matrix(~ grp - 1)  # -1 pour avoir les q indicatrices (sans intercept)

```

```{r adpls_M1}

# Centrage-réduction de X
X_scaled <- scale(X, center = TRUE, scale = TRUE)

# Métrique identité
M1 <- diag(1, ncol(X))

# ADPLS avec M = I
out1 <- adpls_full(X_scaled, Y, H = 3, M = M1, center_scale = FALSE)

# Indicateurs de qualité
data.frame(
  Axe = 1:3,
  S = round(out1$S, 3),
  R2 = round(out1$R2, 3),
  Discriminant = round(out1$S * out1$R2, 3)
)

```

## 2. Interprétation des résultats

```{r}

# Plan discriminant 1-2
plot_adpls(
  out,
  Y = Y,
  Y_labels = grp,
  h = 1,
  m = 2,
  show_variables = TRUE,
  main = "Plan discriminant 1-2",
  cex_ind = 0.5,  
  cex_cent = 1.5,     
  xlim = c(-2.5, 2.5),
  ylim = c(-2.5, 2.5)
)

```

```{r}

# Affichage des coordonnées des variables sur les axes 1 et 2
var_coords_12 <- out$var_coords[, 1:2]
colnames(var_coords_12) <- c("Axe_1", "Axe_2")

# Variables les plus corrélées à l'axe 1 (en valeur absolue)
cat("Variables les plus corrélées à l'axe 1 :\n")
top_axe1 <- var_coords_12[order(abs(var_coords_12[, "Axe_1"]), decreasing = TRUE)[1:10], ]
print(round(top_axe1, 3))

cat("\n\nVariables les plus corrélées à l'axe 2 :\n")
top_axe2 <- var_coords_12[order(abs(var_coords_12[, "Axe_2"]), decreasing = TRUE)[1:10], ]
print(round(top_axe2, 3))

```

